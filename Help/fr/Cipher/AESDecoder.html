<html><head><title>AESDecoder</title><meta charset="utf-8"></head>
<body bgcolor="#FFFFDF" link="#009999" vlink="#006666" alink="#006666">
<font face="Arial" size="2"><p align="center"><b><font size="4">AESDecoder()</font></b></p>
<p><b>Syntaxe</b></p><blockquote>
Resultat = <font color="#006666"><b>AESDecoder</b></font>(*Entrée, *Sortie, Taille, *Cle, Bits, *VecteurInitialisation [, Mode])</blockquote>

</blockquote>
<b>Description</b><br><blockquote>

Décode les données du tampon d'entrée 
en utilisant l'algorithme AES dans le 
tampon de sortie. 

</blockquote><p><b>Arguments</b></p><blockquote>
<style type="text/css">
table.parameters { border-spacing: 0px; border-style: none; border-collapse: collapse; }
table.parameters td { border-width: 1px; padding: 6px; border-style: solid; border-color: gray; vertical-align: top; font-family:Arial; font-size:10pt; }
</style>
<table width="90%" class="parameters">
<tr><td width="10%"><i>*Entree</i></td>
<td width="90%"> 
Le tampon d'entrée avec les données en 
clair. 

</td></tr>
<tr><td><i>*Sortie</i></td>
<td> 
Le tampon de sortie qui reçoit les 
données codées. <br>
Il doit être différent du tampon 
d'entrée. 

</td></tr>
<tr><td><i>Taille</i></td>
<td> 
Le nombre d'octets à encoder.<br>
Au moins 16 octets sinon des données 
de rembourrage doivent être ajoutées 
dans le tampon d'entrée avant le codage, 
afin d'obtenir ces 16 octets minimum. 

</td></tr>
<tr><td><i>*Cle</i></td>
<td> 
Un tampon contenant la clé de codage.<br>
<a href="derivecipherkey.html">DeriveCipherKey()</a> peut être utilisée pour créer cette clé à partir d'un mot de passe. 
<pre><font face="Courier New, Courier, mono" size="2">  Sa taille dépend du paramètre 'Bits': 
    l6 octets pour le cryptage 128 bits 
    24 octets pour le cryptage 192 bits
    32 octets pour le cryptage 256 bits
</font></pre>

</td></tr>
<tr><td><i>Bits</i></td>
<td> 
La taille de la clé utilisée par le 
chiffrement. <br>
Les valeurs valides sont 128, 192 et 256. 

</td></tr>
<tr><td><i>*VecteurInitialisation</i></td>
<td> 
Est un bloc tampon de données aléatoires, 
utilisé pour initialiser le chiffrement 
afin d'empêcher toute violation de 
décodage (uniquement nécessaire si vous 
utilisez le  mode <font color="#924B72">#PB_Cipher_CBC</font>). 
Sa taille vaut toujours 16 octets. 
Le contenu de ce bloc doit correspondre 
à celui qui a été utilisé pour 
<a href="aesencoder.html">encoder</a> les données. 

</td></tr>
<tr><td><i>Mode (optionnel)</i></td>
<td> 
<pre><font face="Courier New, Courier, mono" size="2">  <font color="#924B72">#PB_Cipher_CBC</font>: Mode par défaut (Cipher Block Chaining). Besoin de '*VecteurInitialisation'.
                  Recommandé car plus sûr que le mode ECB.
  <font color="#924B72">#PB_Cipher_ECB</font>: Mode Alternatif (Electronic CodeBook). Pas besoin de '*VecteurInitialisation'
                  ni de chaînage(chaque bloc est codé indépendamment). Cryptage très faible comparé à CBC
                  et ne devrait pas être utilisé pour un cryptage sérieux.
</font></pre>

</td></tr>
</table>
</blockquote><p><b>Valeur de retour</b></p><blockquote>

Renvoie une valeur non nulle si le 
décodage a réussi, zéro sinon. 

</blockquote><p><b>Remarques</b></p><blockquote>

Pour plus d'informations à propos de 
AES et voir des exemples: <a href="aesencoder.html">AESEncoder()</a>. 

</blockquote><p><b>Voir aussi</b></p><blockquote>

<a href="aesencoder.html">AESEncoder()</a>, <a href="startaescipher.html">StartAESCipher()</a>, <a href="derivecipherkey.html">DeriveCipherKey()</a> 

</Blockquote><p><b>OS Supportés </b><Blockquote>Tous</Blockquote></p><center><a href=index.html>Cipher Index</a> - <a href=aesencoder.html>AESEncoder()</a> -><br><br>

</body></html>