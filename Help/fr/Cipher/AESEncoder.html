<html><head><title>AESEncoder</title><meta charset="utf-8"></head>
<body bgcolor="#FFFFDF" link="#009999" vlink="#006666" alink="#006666">
<font face="Arial" size="2"><p align="center"><b><font size="4">AESEncoder()</font></b></p>
<p><b>Syntaxe</b></p><blockquote>
Resultat = <font color="#006666"><b>AESEncoder</b></font>(*Entree, *Sortie, Taille, *Cle, Bits, *VecteurInitialisation [, Mode])</blockquote>

</blockquote>
<b>Description</b><br><blockquote>

Encode les données du tampon d'entrée 
en utilisant l'algorithme AES dans le 
tampon de sortie. 

</blockquote><p><b>Arguments</b></p><blockquote>
<style type="text/css">
table.parameters { border-spacing: 0px; border-style: none; border-collapse: collapse; }
table.parameters td { border-width: 1px; padding: 6px; border-style: solid; border-color: gray; vertical-align: top; font-family:Arial; font-size:10pt; }
</style>
<table width="90%" class="parameters">
<tr><td width="10%"><i>*Entree</i></td>
<td width="90%"> 
Le tampon d'entrée avec les données en 
clair. 

</td></tr>
<tr><td><i>*Sortie</i></td>
<td> 
Le tampon de sortie qui reçoit les 
données codées. <br>
Il doit être différent du tampon 
d'entrée. 

</td></tr>
<tr><td><i>Taille</i></td>
<td> 
Le nombre d'octets à encoder.<br>
Au moins 16 octets sinon des données de 
rembourrage doivent être ajoutées dans 
le tampon d'entrée avant le codage, 
afin d'obtenir ces 16 octets minimum. 

</td></tr>
<tr><td><i>*Cle</i></td>
<td> 
Un tampon contenant la clé de codage.<br>
<a href="derivecipherkey.html">DeriveCipherKey()</a> peut être utilisée pour créer cette clé à partir d'un mot de passe. 
<pre><font face="Courier New, Courier, mono" size="2">  Sa taille dépend du paramètre 'Bits': 
    l6 octets pour le cryptage 128 bits 
    24 octets pour le cryptage 192 bits
    32 octets pour le cryptage 256 bits
</font></pre>

</td></tr>
<tr><td><i>Bits</i></td>
<td> 
La taille de la clé utilisée par le 
chiffrement. <br>
Les valeurs valides sont 128, 192 et 256. 

</td></tr>
<tr><td><i>*VecteurInitialisation</i></td>
<td> 
Est un bloc tampon de données aléatoires 
de 16 octets, utilisé pour initialiser 
le chiffrement afin d'empêcher toute 
violation de décodage (uniquement 
nécessaire si vous utilisez le  mode 
<font color="#924B72">#PB_Cipher_CBC</font>). 

</td></tr>
<tr><td><i>Mode (optionnel)</i></td>
<td> 
<pre><font face="Courier New, Courier, mono" size="2">  <font color="#924B72">#PB_Cipher_CBC</font>: Mode par défaut (Cipher Block Chaining). Besoin de '*VecteurInitialisation'.
                  Recommandé car plus sûr que le mode ECB.
  <font color="#924B72">#PB_Cipher_ECB</font>: Mode Alternatif (Electronic CodeBook). Pas besoin de '*VecteurInitialisation'
                  ni de chaînage(chaque bloc est codé indépendamment). Cryptage très faible comparé à CBC
                  et ne devrait pas être utilisé pour un cryptage sérieux.
</font></pre>

</td></tr>
</table>
</blockquote><p><b>Valeur de retour</b></p><blockquote>

Renvoie une valeur non nulle si 
l'encodage a réussie, zéro sinon. 

</blockquote><p><b>Remarques</b></p><blockquote>

AES est un algorithme de chiffrement de 
l'industrie qui a un bon équilibre entre 
la vitesse et la sécurité. 
Voici l'introduction wikipedia sur AES: 
&quot;En cryptographie, le Advanced 
Encryption Standard (AES) est une norme 
de cryptage adopté par le gouvernement 
des États-Unis. La norme comprend trois 
chiffrements par bloc, AES-128, AES-192 
et AES-256. Chaque chiffrement AES a une 
taille de bloc de 128 bits, avec des 
tailles de clés de 128, 192 et 256 bits, 
respectivement. 
Les chiffrements AES ont été analysés de 
façon approfondie et sont maintenant 
utilisés dans le monde entier. 
<br>
<br>
PureBasic utilise une mise en œuvre 
conforme à la RFC de l'AES. 
Plus d'informations peuvent être 
trouvées dans le RFC 3602 : 
<a href="http://www.ietf.org/rfc/rfc3602.txt">http://www.ietf.org/rfc/rfc3602.txt</a>. 

</blockquote><p><b>Exemple:</b> CBC</p><blockquote>

<pre><font face="Courier New, Courier, mono" size="2">  <font color="#006666">; Crypter une chaîne de caractères</font>
  <font color="#006666">;</font>
  String$ = &quot;Hello voici un test pour AES&quot;
  
  StringMemorySize =<font color="#006666"> StringByteLength</font>(String$) +<font color="#006666"> SizeOf</font>(Character) <font color="#006666">; Espace pour la chaîne et son caractère 'nul' de terminaison de chaîne</font>
  *CipheredString =<font color="#006666"> AllocateMemory</font>(StringMemorySize)   
  *DecipheredString =<font color="#006666"> AllocateMemory</font>(StringMemorySize) 
  
  <b><font color="#006666">If</font></b> <font color="#006666">AESEncoder</font>(@String$, *CipheredString,<font color="#006666"> StringByteLength</font>(String$), ?Key, 128, ?InitializationVector)
    <b><font color="#006666">Debug</font></b> &quot;Codé : &quot;+<font color="#006666">PeekS</font>(*CipheredString) <font color="#006666">; Attention, ça s'arrêtera sur le premier octet nul, uniquement à des fins de démonstration</font>
    
<font color="#006666">    AESDecoder</font>(*CipheredString, *DecipheredString,<font color="#006666"> StringByteLength</font>(String$), ?Key, 128, ?InitializationVector)
    <b><font color="#006666">Debug</font></b> &quot;Décodé : &quot;+<font color="#006666">PeekS</font>(*DecipheredString)
  <b><font color="#006666">EndIf</font></b>

  <b><font color="#006666">DataSection</font></b>
    Key:
      <b><font color="#006666">Data</font></b>.b $06, $a9, $21, $40, $36, $b8, $a1, $5b, $51, $2e, $03, $d5, $34, $12, $00, $06
  
    InitializationVector:
      <b><font color="#006666">Data</font></b>.b $3d, $af, $ba, $42, $9d, $9e, $b4, $30, $b4, $22, $da, $80, $2c, $9f, $ac, $41
  <b><font color="#006666">EndDataSection</font></b>
  
</font></pre>

</blockquote><p><b>Exemple:</b> ECB</p><blockquote>

<pre><font face="Courier New, Courier, mono" size="2">  String$ = &quot;Hello voici un test pour AES&quot;
  
  *CipheredString   =<font color="#006666"> AllocateMemory</font>(<font color="#006666">StringByteLength</font>(String$) +<font color="#006666"> SizeOf</font>(Character)) <font color="#006666">; Espace pour la chaîne de caractère</font>
  *DecipheredString =<font color="#006666"> AllocateMemory</font>(<font color="#006666">StringByteLength</font>(String$) +<font color="#006666"> SizeOf</font>(Character)) <font color="#006666">; et le caractère nul de fin de chaîne</font>
  
  <b><font color="#006666">If</font></b> <font color="#006666">AESEncoder</font>(@String$, *CipheredString,<font color="#006666"> MemorySize</font>(*CipheredString), ?Key, 128, 0, <font color="#924B72">#PB_Cipher_ECB</font>)
    <b><font color="#006666">Debug</font></b> &quot;Chiffré: &quot; +<font color="#006666"> PeekS</font>(*CipheredString)
    
<font color="#006666">    AESDecoder</font>(*CipheredString, *DecipheredString,<font color="#006666"> MemorySize</font>(*DecipheredString), ?Key, 128, 0, <font color="#924B72">#PB_Cipher_ECB</font>)
    <b><font color="#006666">Debug</font></b> &quot;Déchiffré: &quot; +<font color="#006666"> PeekS</font>(*DecipheredString)
  <b><font color="#006666">EndIf</font></b>
  
  <b><font color="#006666">DataSection</font></b>
    Key:
    <b><font color="#006666">Data</font></b>.a $06, $a9, $21, $40, $36, $b8, $a1, $5b, $51, $2e, $03, $d5, $34, $12, $00, $06
  <b><font color="#006666">EndDataSection</font></b>
  
</font></pre>

</blockquote><p><b>Voir aussi</b></p><blockquote>

<a href="aesdecoder.html">AESDecoder()</a>, <a href="startaescipher.html">StartAESCipher()</a>, <a href="derivecipherkey.html">DeriveCipherKey()</a> 

</Blockquote><p><b>OS Supportés </b><Blockquote>Tous</Blockquote></p><center><- <a href=aesdecoder.html>AESDecoder()</a> - <a href=index.html>Cipher Index</a> - <a href=addcipherbuffer.html>AddCipherBuffer()</a> -><br><br>

</body></html>